'use strict';

const SlackMention = require('./mention');
const { TextMessage, Message } = require('hubot/es2015');

/**
 * Represents a message generated by an emoji reaction event
 *
 * @constructor
 * @param {string} type - A String indicating 'reaction_added' or 'reaction_removed'
 * @param {User} user - A User instance that reacted to the item.
 * @param {string} reaction - A String identifying the emoji reaction.
 * @param {Object} item - An Object identifying the target message, file, or comment item.
 * @param {User} [item_user] - A String indicating the user that posted the item. If the item was created by a
 * custom integration (not part of a Slack app with a bot user), then this value will be undefined.
 * @param {string} event_ts - A String of the reaction event timestamp.
 */
class ReactionMessage extends Message {
  constructor(type, user, reaction, item_user, item, event_ts) {
    super(user)
    this.type = type.replace("reaction_", "");
    this.user = user;
    this.reaction = reaction;
    this.item_user = item_user;
    this.item = item;
    this.event_ts = event_ts;
  }
}

/**
 * Represents a message generated by an file_shared event
 *
 * @constructor
 * @param {User} user - A User instance that reacted to the item.
 * @param {string} file_id - A String identifying the file_id of the file that was shared.
 * @param {string} event_ts - A String of the file_shared event timestamp.
 */
class FileSharedMessage extends Message {
  constructor(user, file_id, event_ts) {
    super(user);
    this.file_id = file_id;
    this.event_ts = event_ts;
  }
}

/**
 * Represents a message generated by a /me invocation
 *
 * @constructor
 * @param {User} user - A User instance that created the /me message
 * @param {string} text - Text of the /me message
 * @param {string} event_ts - event timestamp
 */
class MeMessage extends TextMessage {
  constructor(user, text, event_ts) {
    super(user, text, event_ts);
    this.user = user;
    this.text = text;
    this.event_ts = event_ts;
  }
}

/**
 * Represents a message generated by a presence change event
 *
 * @constructor
 * @param {Array<User>} users - Array of users that changed their status
 * @param {string} presence - Status is either 'active' or 'away'
 */
class PresenceMessage extends Message {
  constructor(users, presence) {
    super({ room: ""});
    this.users = users;
    this.presence = presence;
  }
}

/**
 * Represents a TextMessage created from the Slack adapter
 *
 * @constructor
 * @param {User} user - The User who sent this message
 * @param {string|undefined} text - The parsed message text. Its no longer recommended to use this property.
 * The `buildText()` method can be used to parse the raw text and populate the `text` property.
 * @param {string|undefined} rawText - The unparsed message text. Its no longer recommended to use this property.
 * The constructor will default to the `rawMessage.text` value.
 * @param {Object} rawMessage - The Slack Message object
 * @param {string} rawMessage.text
 * @param {string} rawMessage.ts
 * @param {string} [rawMessage.thread_ts] - the identifier for the thread the message is a part of
 * @param {string} [rawMessage.attachments] - Slack message attachments
 * @param {string} channel_id - The conversation where this message was sent.
 * @param {string} robot_name - The Slack username for this robot
 * @param {string} robot_alias - The alias for this robot
 */
class SlackTextMessage extends TextMessage {
  static #MESSAGE_REGEX;
  static #MESSAGE_RESERVED_KEYWORDS;
  constructor(user, text, rawText, rawMessage, channel_id, robot_name, robot_alias) {
    super(user, text, rawMessage.ts);

    SlackTextMessage.#MESSAGE_REGEX = /<([@#!])?([^>|]+)(?:\|([^>]+))?>/g;
    SlackTextMessage.#MESSAGE_RESERVED_KEYWORDS = ["channel", "group", "everyone", "here"];

    this.user = user;
    this.text = text;
    this.rawMessage = rawMessage;
    this._channel_id = channel_id;
    this._robot_name = robot_name;
    this._robot_alias = robot_alias;
    this.rawText = rawText || this.rawMessage.text;
    if (this.rawMessage.thread_ts) {
      this.thread_ts = this.rawMessage.thread_ts;
    }
    this.mentions = [];
  }

  /**
   * Build the text property, a flat string representation of the contents of this message.
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @param {function} cb - callback for the result
   */
  buildText = (client, cb) => {
    let text = this.rawMessage.text ? this.rawMessage.text : "";
    if (this.rawMessage.attachments) {
      const attachment_text = this.rawMessage.attachments.map(a => {
        return a.fallback;
      }).join("\n");
      if (attachment_text.length > 0) {
        text += "\n" + attachment_text;
      }
    }
    const mentionFormatting = this.replaceLinks(client, text);
    const fetchingConversationInfo = client.fetchConversation(this._channel_id);

    return Promise.all([mentionFormatting, fetchingConversationInfo]).then(results => {
      const replacedText = results[0]
      const conversationInfo = results[1];
      text = replacedText;
      text = text.replace(/&lt;/g, "<");
      text = text.replace(/&gt;/g, ">");
      text = text.replace(/&amp;/g, "&");
      if (conversationInfo.is_im) {
        const startOfText = text.indexOf("@") === 0 ? 1 : 0;
        const robotIsNamed = text.indexOf(this._robot_name) === startOfText || text.indexOf(this._robot_alias) === startOfText;
        if (!robotIsNamed) {
          text = this._robot_name + " " + text;
        }
      }
      this.text = text;
      return cb();
    }).catch(error => {
      client.robot.logger.error("An error occurred while building text: " + error.message);
      return cb(error);
    });
  };

  /**
   * Replace links inside of text
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @returns {Promise<string>}
   */
  replaceLinks = (client, text) => {
    // var cursor, label, link, m, parts, regex, result, type;
    const regex = SlackTextMessage.#MESSAGE_REGEX;
    const parts = [];
    regex.lastIndex = 0;
    let cursor = 0;
    let result;
    while ((result = regex.exec(text))) {
      const m = result[0], type = result[1], label = result[3];
      let link = result[2];
      switch (type) {
        case "@":
          if (label) {
            parts.push(text.slice(cursor, result.index), "@" + label);
            this.mentions.push(new SlackMention(link, "user", void 0));
          } else {
            parts.push(text.slice(cursor, result.index), this.replaceUser(client, link, this.mentions));
          }
          break;
        case "#":
          if (label) {
            parts.push(text.slice(cursor, result.index), "\#" + label);
            this.mentions.push(new SlackMention(link, "conversation", void 0));
          } else {
            parts.push(text.slice(cursor, result.index), this.replaceConversation(client, link, this.mentions));
          }
          break;
        case "!":
          if (SlackTextMessage.#MESSAGE_RESERVED_KEYWORDS.indexOf(link) >= 0) {
            parts.push(text.slice(cursor, result.index), "@" + link);
          } else if (label) {
            parts.push(text.slice(cursor, result.index), label);
          } else {
            parts.push(text.slice(cursor, result.index), m);
          }
          break;
        default:
          link = link.replace(/^mailto:/, "");
          if (label && -1 === link.indexOf(label)) {
            parts.push(text.slice(cursor, result.index), label + " (" + link + ")");
          } else {
            parts.push(text.slice(cursor, result.index), link);
          }
      }
      cursor = regex.lastIndex;
      if (result[0].length === 0) {
        regex.lastIndex++;
      }
    }
    parts.push(text.slice(cursor));
    return Promise.all(parts).then(substrings => substrings.join(""));
  };

  /**
   * Creates a mention from a user ID
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @param {string} id - the user ID
   * @param {Array<Mention>} mentions - a mentions array that is updated to include this user mention
   * @returns {Promise<string>} - a string that can be placed into the text for this mention
   */
  replaceUser = (client, id, mentions) => {
    return client.fetchUser(id).then(res => {
        mentions.push(new SlackMention(res.id, "user", res));
        return "@" + res.name;
      }).catch(error => {
        client.robot.logger.error("Error getting user info " + id + ": " + error.message);
        return "<@" + id + ">";
      });
  };

  /**
   * Creates a mention from a conversation ID
   *
   * @private
   * @param {SlackClient} client - a client that can be used to get more data needed to build the text
   * @param {string} id - the conversation ID
   * @param {Array<Mention>} mentions - a mentions array that is updated to include this conversation mention
   * @returns {Promise<string>} - a string that can be placed into the text for this mention
   */
  replaceConversation = (client, id, mentions) => {
    return client.fetchConversation(id).then(conversation => {
      if (conversation != null) {
        mentions.push(new SlackMention(conversation.id, "conversation", conversation));
        return "\#" + conversation.name;
      } else {
        return "<\#" + id + ">";
      }
    }).catch(error => {
      client.robot.logger.error("Error getting conversation info " + id + ": " + error.message);
      return "<\#" + id + ">";
    });
  };

  /**
   * Factory method to construct SlackTextMessage
   * @public
   * @param {User} user - The User who sent this message
   * @param {string|undefined} text - The parsed message text. Its no longer recommended to use this property.
   * The `buildText()` method can be used to parse the raw text and populate the `text` property.
   * @param {string|undefined} rawText - The unparsed message text. Its no longer recommended to use this property.
   * The constructor will default to the `rawMessage.text` value.
   * @param {Object} rawMessage - The Slack Message object
   * @param {string} rawMessage.text
   * @param {string} rawMessage.ts
   * @param {string} [rawMessage.thread_ts] - the identifier for the thread the message is a part of
   * @param {string} [rawMessage.attachments] - Slack message attachments
   * @param {string} channel_id - The conversation where this message was sent.
   * @param {string} robot_name - The Slack username for this robot
   * @param {string} robot_alias - The alias for this robot
   * @param {SlackClient} client - client used to fetch more data
   * @param {function} cb - callback to return the result
   */
  static makeSlackTextMessage = (user, text, rawText, rawMessage, channel_id, robot_name, robot_alias, client, cb) => {
    const message = new SlackTextMessage(user, text, rawText, rawMessage, channel_id, robot_name, robot_alias);
    const done = message => {
      return setImmediate(() => cb(null, message));
    };
    if (message.text == null) {
      return message.buildText(client, function(error) {
        if (error) {
          return cb(error);
        }
        return done(message);
      });
    } else {
      return done(message);
    }
  };
}

module.exports = {
  ReactionMessage,
  FileSharedMessage,
  MeMessage,
  PresenceMessage,
  SlackTextMessage
}
